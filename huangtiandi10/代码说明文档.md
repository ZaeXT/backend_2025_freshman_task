# 代码 & 数据结构说明（关键片段）

## 总概述

本项目在登录时用到jwt以提高安全性
在权限划分时使用了casbin架构

另外本项目在权限划分过程中设计：随着提问次数的增加，来提高权限等级，调用更好的ai模型

## A. 数据库表（概要）
users

id (bigint, PK)

username (varchar, unique)

password (longtext)

vip_level (bigint) — 0/1/2 ...

question_count (bigint)

created_at (timestamp) 等

------------

qa_records

id (bigint, PK)

user_id (bigint, FK -> users.id)

question (text)

answer (text)

model_used (varchar)

created_at (timestamp) （可选）



## B. Go - Models（推荐）
// models/user.go
type User struct {
    ID            int64     `gorm:"primaryKey" json:"id"`
    Username      string    `gorm:"size:191;unique" json:"username"`
    Password      string    `json:"-"` // 不返回给前端
    VIPLevel      int       `gorm:"column:vip_level" json:"vip_level"`
    QuestionCount int       `gorm:"column:question_count" json:"question_count"`
    CreatedAt     time.Time `json:"created_at"`
}

// models/qa_record.go
type QARecord struct {
    ID        int64  `gorm:"primaryKey" json:"id"`
    UserID    int64  `gorm:"not null" json:"user_id"`
    Question  string `gorm:"type:text;not null" json:"question"`
    Answer    string `gorm:"type:text;not null" json:"answer"`
    ModelUsed string `json:"model_used"`
    // 但不想返回给前端：
    CreatedAt time.Time `json:"-" gorm:"autoCreateTime"`
}

## C. DAO
SaveQARecord（保存记录）
func SaveQARecord(userID int64, question, answer, model string) error {
    qa := models.QARecord{
        UserID:    userID,
        Question:  question,
        Answer:    answer,
        ModelUsed: model,
    }
    return DB.Create(&qa).Error
}

GetQARecordsByUser
func GetQARecordsByUser(userID int64) ([]models.QARecord, error) {
    var records []models.QARecord
    if err := DB.Where("user_id = ?", userID).Order("id DESC").Find(&records).Error; err != nil {
        return nil, err
    }
    return records, nil
}

DeleteQARecord（检查 RowsAffected）
func DeleteQARecord(id int64) error {
    res := DB.Delete(&models.QARecord{}, id)
    if res.Error != nil {
        return res.Error
    }
    if res.RowsAffected == 0 {
        return fmt.Errorf("记录不存在")
    }
    return nil
}

ClearQARecords（返回删除计数）
func ClearQARecords(userID int64) (int64, error) {
    res := DB.Where("user_id = ?", userID).Delete(&models.QARecord{})
    if res.Error != nil {
        return 0, res.Error
    }
    return res.RowsAffected, nil
}

## D. Controller 关键实现片段
Register（区分用户名重复）
func Register(c *gin.Context) {
    var req RegisterRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "参数错误"})
        return
    }

    user := models.User{
        Username:      req.Username,
        Password:      utils.HashPassword(req.Password),
        VIPLevel:      0,
        QuestionCount: 0,
    }

    err := dao.CreateUser(&user)
    if err != nil {
        if strings.Contains(err.Error(), "Duplicate entry") {
            c.JSON(http.StatusConflict, gin.H{"error": "用户名已存在"})
        } else {
            c.JSON(http.StatusInternalServerError, gin.H{"error": "注册失败"})
        }
        return
    }
    c.JSON(http.StatusOK, gin.H{"message": "注册成功"})
}

AskQuestion（事务示例：先更新次数，再保存记录）
func AskQuestion(c *gin.Context) {
    userID := c.GetInt64("userID")
    var req AskRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "参数错误"})
        return
    }

    // 获取用户
    user, err := dao.GetUserByID(userID)
    if err != nil { ... }

    // 选择模型（示例：把 int -> "VIP%d" 再用 Casbin）
    role := fmt.Sprintf("VIP%d", user.VIPLevel)
    models := []string{"doubao-seed-1.6-vision","deepseek-v3.1","kimi-k2"}
    var chosen string
    for _, m := range models {
        ok, _ := utils.Enforcer.Enforce(role, m, "use")
        if ok { chosen = m; break }
    }
    if chosen == "" {
        c.JSON(http.StatusForbidden, gin.H{"error": "无可用模型"})
        return
    }

    // 调用 AI
    answer, err := utils.CallAI(chosen, req.Question)
    if err != nil { ... }

    // 使用事务：先更新用户次数->保存记录
    tx := dao.DB.Begin()
    if err := dao.IncUserQuestionCountTx(tx, userID); err != nil {
        tx.Rollback()
        c.JSON(500, gin.H{"error":"更新次数失败"})
        return
    }
    if err := dao.SaveQARecordTx(tx, userID, req.Question, answer, chosen); err != nil {
        tx.Rollback()
        c.JSON(500, gin.H{"error":"保存记录失败"})
        return
    }
    tx.Commit()

    c.JSON(200, gin.H{
        "question": req.Question,
        "answer": answer,
        "model": chosen,
        "question_count": user.QuestionCount+1,
    })
}


说明：SaveQARecordTx、IncUserQuestionCountTx 为基于 tx *gorm.DB 的事务版本 DAO，推荐实现以保证一致性。

GetHistory（不在每条记录返回 question_count，单独返回）
func GetHistory(c *gin.Context) {
    userID := c.GetInt64("userID")
    user, err := dao.GetUserByID(userID)
    if err != nil { ... }

    records, err := dao.GetQARecordsByUser(userID)
    if err != nil { ... }

    c.JSON(http.StatusOK, gin.H{
        "question_count": user.QuestionCount,
        "records": records,
    })
}

DeleteQuestion（用 DeleteQARecord 的改进版）
func DeleteQuestion(c *gin.Context) {
    idStr := c.Param("id")
    id, err := strconv.ParseInt(idStr, 10, 64)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error":"无效ID"})
        return
    }
    if err := dao.DeleteQARecord(id); err != nil {
        if err.Error() == "记录不存在" {
            c.JSON(http.StatusNotFound, gin.H{"error":"记录不存在"})
        } else {
            c.JSON(http.StatusInternalServerError, gin.H{"error":"删除失败"})
        }
        return
    }
    c.JSON(http.StatusOK, gin.H{"message":"删除成功"})
}
## F. JWT 鉴权机制
token, _ := utils.GenerateToken(user.ID, user.Username)
func JWTAuth() gin.HandlerFunc {
    return func(c *gin.Context) {
        tokenString := c.GetHeader("Authorization")
        claims, err := utils.ParseToken(tokenString)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "无效的Token"})
            c.Abort()
            return
        }
        c.Set("userID", claims.UserID)
        c.Next()
    }
}
## G. Casbin 权限控制
[request_definition]
r = sub, obj, act

[policy_definition]
p = sub, obj, act

[role_definition]
g = _, _

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = r.sub == p.sub && r.obj == p.obj && r.act == p.act

p, VIP0, model_deepseek_v3, use
p, VIP1, model_doubao_pro, use
p, VIP2, model_doubao_premium, use

ok, _ := enforcer.Enforce(fmt.Sprintf("VIP%d", user.VipLevel), modelName, "use")
if !ok {
    c.JSON(http.StatusForbidden, gin.H{"error": "无可用模型"})
    return
}

## H. 权限等级升级
func UpdateUserPolicy(user *models.User) {
    if user.QuestionCount > 50 {
        user.VipLevel = 2
    } else if user.QuestionCount > 10 {
        user.VipLevel = 1
    } else {
        user.VipLevel = 0
    }
    dao.UpdateUser(user)
}
